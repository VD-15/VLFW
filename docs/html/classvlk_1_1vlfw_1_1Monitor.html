<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VLFW: vlk::vlfw::Monitor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VLFW
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>vlk</b></li><li class="navelem"><b>vlfw</b></li><li class="navelem"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html">Monitor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classvlk_1_1vlfw_1_1Monitor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vlk::vlfw::Monitor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html" title="Monitor wrapper class.">Monitor</a> wrapper class.  
 <a href="classvlk_1_1vlfw_1_1Monitor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Monitor_8hpp_source.html">Monitor.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvlk_1_1vlfw_1_1Monitor_1_1ConnectEvent.html">ConnectEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sent when a monitor is connected to the system.  <a href="structvlk_1_1vlfw_1_1Monitor_1_1ConnectEvent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvlk_1_1vlfw_1_1Monitor_1_1DisconnectEvent.html">DisconnectEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1e4472fff89e5e52b5a3845941cbac57"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#a1e4472fff89e5e52b5a3845941cbac57">GetHandle</a> ()</td></tr>
<tr class="memdesc:a1e4472fff89e5e52b5a3845941cbac57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the underlying monitor object.  <a href="classvlk_1_1vlfw_1_1Monitor.html#a1e4472fff89e5e52b5a3845941cbac57">More...</a><br /></td></tr>
<tr class="separator:a1e4472fff89e5e52b5a3845941cbac57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063dc4ac6cc6cf6317fdabaad30bdb7a"><td class="memItemLeft" align="right" valign="top">Point&lt; Int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#a063dc4ac6cc6cf6317fdabaad30bdb7a">GetPosition</a> () const</td></tr>
<tr class="memdesc:a063dc4ac6cc6cf6317fdabaad30bdb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of the monitor in screen coordinates.  <a href="classvlk_1_1vlfw_1_1Monitor.html#a063dc4ac6cc6cf6317fdabaad30bdb7a">More...</a><br /></td></tr>
<tr class="separator:a063dc4ac6cc6cf6317fdabaad30bdb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768ca3f19ed50bffec11dd57b23cef0b"><td class="memItemLeft" align="right" valign="top">Point&lt; Int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#a768ca3f19ed50bffec11dd57b23cef0b">GetPhysicalSize</a> () const</td></tr>
<tr class="memdesc:a768ca3f19ed50bffec11dd57b23cef0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the physical size of the monitor in millimeters.  <a href="classvlk_1_1vlfw_1_1Monitor.html#a768ca3f19ed50bffec11dd57b23cef0b">More...</a><br /></td></tr>
<tr class="separator:a768ca3f19ed50bffec11dd57b23cef0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdedb2b88c883282777ebc51369b459"><td class="memItemLeft" align="right" valign="top">Vector2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#aefdedb2b88c883282777ebc51369b459">GetContentScale</a> () const</td></tr>
<tr class="memdesc:aefdedb2b88c883282777ebc51369b459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the content scale of the monitor.  <a href="classvlk_1_1vlfw_1_1Monitor.html#aefdedb2b88c883282777ebc51369b459">More...</a><br /></td></tr>
<tr class="separator:aefdedb2b88c883282777ebc51369b459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f26479874f049edffb4018cf1f5afa3"><td class="memItemLeft" align="right" valign="top">Area&lt; Int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#a6f26479874f049edffb4018cf1f5afa3">GetWorkingArea</a> () const</td></tr>
<tr class="memdesc:a6f26479874f049edffb4018cf1f5afa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the available working area of the monitor in screen coordinates.  <a href="classvlk_1_1vlfw_1_1Monitor.html#a6f26479874f049edffb4018cf1f5afa3">More...</a><br /></td></tr>
<tr class="separator:a6f26479874f049edffb4018cf1f5afa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff029c247e5bcaf6042a1f2f54690a5c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#aff029c247e5bcaf6042a1f2f54690a5c">GetName</a> () const</td></tr>
<tr class="memdesc:aff029c247e5bcaf6042a1f2f54690a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the human-readable name of the monitor.  <a href="classvlk_1_1vlfw_1_1Monitor.html#aff029c247e5bcaf6042a1f2f54690a5c">More...</a><br /></td></tr>
<tr class="separator:aff029c247e5bcaf6042a1f2f54690a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f2a7e22ff17bb16166116d8a8700a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#a65f2a7e22ff17bb16166116d8a8700a9">SetGamma</a> (double gamma)</td></tr>
<tr class="memdesc:a65f2a7e22ff17bb16166116d8a8700a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the gamma exponent of the monitor.  <a href="classvlk_1_1vlfw_1_1Monitor.html#a65f2a7e22ff17bb16166116d8a8700a9">More...</a><br /></td></tr>
<tr class="separator:a65f2a7e22ff17bb16166116d8a8700a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d192bb15a85276bf12566979f2861c6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Color &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#a5d192bb15a85276bf12566979f2861c6">GetGammaRamp</a> () const</td></tr>
<tr class="memdesc:a5d192bb15a85276bf12566979f2861c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the gamma ramp of the monitor.  <a href="classvlk_1_1vlfw_1_1Monitor.html#a5d192bb15a85276bf12566979f2861c6">More...</a><br /></td></tr>
<tr class="separator:a5d192bb15a85276bf12566979f2861c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9c04207b687a8e08c659c221054ddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#aac9c04207b687a8e08c659c221054ddf">SetGammaRamp</a> (const std::vector&lt; Color &gt; &amp;ramp)</td></tr>
<tr class="memdesc:aac9c04207b687a8e08c659c221054ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the full gamma ramp of the monitor.  <a href="classvlk_1_1vlfw_1_1Monitor.html#aac9c04207b687a8e08c659c221054ddf">More...</a><br /></td></tr>
<tr class="separator:aac9c04207b687a8e08c659c221054ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39a773bda3d1bc7efdb860875168666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvlk_1_1vlfw_1_1VideoMode.html">VideoMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#aa39a773bda3d1bc7efdb860875168666">GetVideoMode</a> () const</td></tr>
<tr class="memdesc:aa39a773bda3d1bc7efdb860875168666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current output mode of the monitor.  <a href="classvlk_1_1vlfw_1_1Monitor.html#aa39a773bda3d1bc7efdb860875168666">More...</a><br /></td></tr>
<tr class="separator:aa39a773bda3d1bc7efdb860875168666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f88bdbda209e2446a7f4ee31dcbf214"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structvlk_1_1vlfw_1_1VideoMode.html">VideoMode</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#a9f88bdbda209e2446a7f4ee31dcbf214">GetSupportedVideoModes</a> () const</td></tr>
<tr class="memdesc:a9f88bdbda209e2446a7f4ee31dcbf214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all supported output modes of the monitor.  <a href="classvlk_1_1vlfw_1_1Monitor.html#a9f88bdbda209e2446a7f4ee31dcbf214">More...</a><br /></td></tr>
<tr class="separator:a9f88bdbda209e2446a7f4ee31dcbf214"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af0d97f731711ee64e47783b80550fd63"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvlk_1_1vlfw_1_1Monitor.html">Monitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#af0d97f731711ee64e47783b80550fd63">GetPrimaryMonitor</a> ()</td></tr>
<tr class="memdesc:af0d97f731711ee64e47783b80550fd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the user's preferred monitor.  <a href="classvlk_1_1vlfw_1_1Monitor.html#af0d97f731711ee64e47783b80550fd63">More...</a><br /></td></tr>
<tr class="separator:af0d97f731711ee64e47783b80550fd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71651d1dc59bee31af4b0463b650633"><td class="memItemLeft" align="right" valign="top">static Int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#ae71651d1dc59bee31af4b0463b650633">GetMonitorCount</a> ()</td></tr>
<tr class="memdesc:ae71651d1dc59bee31af4b0463b650633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of currently connected monitors.  <a href="classvlk_1_1vlfw_1_1Monitor.html#ae71651d1dc59bee31af4b0463b650633">More...</a><br /></td></tr>
<tr class="separator:ae71651d1dc59bee31af4b0463b650633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ae3be946fe05a9526f20e0c697874b"><td class="memItemLeft" align="right" valign="top">static const std::vector&lt; <a class="el" href="classvlk_1_1vlfw_1_1Monitor.html">Monitor</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#ac1ae3be946fe05a9526f20e0c697874b">GetMonitors</a> ()</td></tr>
<tr class="memdesc:ac1ae3be946fe05a9526f20e0c697874b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns every currently connected monitor.  <a href="classvlk_1_1vlfw_1_1Monitor.html#ac1ae3be946fe05a9526f20e0c697874b">More...</a><br /></td></tr>
<tr class="separator:ac1ae3be946fe05a9526f20e0c697874b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html" title="Monitor wrapper class.">Monitor</a> wrapper class. </p>
<p>Certain functions of this class require an instance of <a class="el" href="classvlk_1_1vlfw_1_1VLFWMain.html" title="Handles window-related events.">VLFWMain</a> to be constructed prior in order to function properly. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aefdedb2b88c883282777ebc51369b459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdedb2b88c883282777ebc51369b459">&#9670;&nbsp;</a></span>GetContentScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector2 Monitor::GetContentScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the content scale of the monitor. </p>
<dl class="section user"><dt>From GLFW's Documentation</dt><dd>This function retrieves the content scale for the specified monitor. The content scale is the ratio between the current DPI and the platform's default DPI. This is especially important for text and any UI elements. If the pixel dimensions of your UI scaled by this look appropriate on your machine then it should appear at a reasonable size on other machines regardless of their DPI and scaling settings. This relies on the system DPI and scaling settings being somewhat correct. The content scale may depend on both the monitor resolution and pixel density and on user settings. It may be very different from the raw DPI calculated from the physical size and current resolution.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function must only be called from the main thread.<br  />
 Access to this class is not synchronized.<br  />
 This function will not block the calling thread.<br  />
 </dd></dl>

</div>
</div>
<a id="a5d192bb15a85276bf12566979f2861c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d192bb15a85276bf12566979f2861c6">&#9670;&nbsp;</a></span>GetGammaRamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;Color&gt;&amp; vlk::vlfw::Monitor::GetGammaRamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the gamma ramp of the monitor. </p>
<dl class="section user"><dt>Thread Safety</dt><dd>This function must only be called from the main thread.<br  />
 Access to this class is not synchronized.<br  />
 This function will not block the calling thread.<br  />
 </dd></dl>

</div>
</div>
<a id="a1e4472fff89e5e52b5a3845941cbac57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4472fff89e5e52b5a3845941cbac57">&#9670;&nbsp;</a></span>GetHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* vlk::vlfw::Monitor::GetHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the underlying monitor object. </p>
<p>This handle is owned by GLFW and functions as a valid <code>GLFWmonitor*</code> object should you want to use the library directly. </p>

</div>
</div>
<a id="ae71651d1dc59bee31af4b0463b650633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71651d1dc59bee31af4b0463b650633">&#9670;&nbsp;</a></span>GetMonitorCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Int Monitor::GetMonitorCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of currently connected monitors. </p>
<dl class="section user"><dt>Thread Safety</dt><dd>This function must only be called from the main thread.<br  />
 Access to this class is not synchronized.<br  />
 This function will not block the calling thread.<br  />
 </dd></dl>

</div>
</div>
<a id="ac1ae3be946fe05a9526f20e0c697874b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ae3be946fe05a9526f20e0c697874b">&#9670;&nbsp;</a></span>GetMonitors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classvlk_1_1vlfw_1_1Monitor.html">Monitor</a> * &gt; &amp; Monitor::GetMonitors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns every currently connected monitor. </p>
<dl class="section user"><dt>Thread Safety</dt><dd>This function must only be called from the main thread.<br  />
 Access to this class is not synchronized.<br  />
 This function will not block the calling thread.<br  />
 </dd></dl>

</div>
</div>
<a id="aff029c247e5bcaf6042a1f2f54690a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff029c247e5bcaf6042a1f2f54690a5c">&#9670;&nbsp;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Monitor::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the human-readable name of the monitor. </p>
<dl class="section user"><dt>From GLFW's Documentation</dt><dd>This function returns a human-readable name, encoded as UTF-8, of the specified monitor. The name typically reflects the make and model of the monitor and is not guaranteed to be unique among the connected monitors.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function must only be called from the main thread.<br  />
 Access to this class is not synchronized.<br  />
 This function will not block the calling thread.<br  />
 </dd></dl>

</div>
</div>
<a id="a768ca3f19ed50bffec11dd57b23cef0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768ca3f19ed50bffec11dd57b23cef0b">&#9670;&nbsp;</a></span>GetPhysicalSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point&lt; Int &gt; Monitor::GetPhysicalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the physical size of the monitor in millimeters. </p>
<dl class="section user"><dt>Thread Safety</dt><dd>This function must only be called from the main thread.<br  />
 Access to this class is not synchronized.<br  />
 This function will not block the calling thread.<br  />
 </dd></dl>

</div>
</div>
<a id="a063dc4ac6cc6cf6317fdabaad30bdb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063dc4ac6cc6cf6317fdabaad30bdb7a">&#9670;&nbsp;</a></span>GetPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point&lt; Int &gt; Monitor::GetPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the position of the monitor in screen coordinates. </p>
<p>The returned point is the distance between the top-left corner of the primary monitor to the top-left corner of this monitor </p>

</div>
</div>
<a id="af0d97f731711ee64e47783b80550fd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d97f731711ee64e47783b80550fd63">&#9670;&nbsp;</a></span>GetPrimaryMonitor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvlk_1_1vlfw_1_1Monitor.html">Monitor</a> * Monitor::GetPrimaryMonitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the user's preferred monitor. </p>
<p>The returned pointer is owned by <a class="el" href="classvlk_1_1vlfw_1_1VLFWMain.html" title="Handles window-related events.">VLFWMain</a></p>
<dl class="section user"><dt>Thread Safety</dt><dd>This function must only be called from the main thread.<br  />
 Access to this class is not synchronized.<br  />
 This function will not block the calling thread.<br  />
 </dd></dl>

</div>
</div>
<a id="a9f88bdbda209e2446a7f4ee31dcbf214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f88bdbda209e2446a7f4ee31dcbf214">&#9670;&nbsp;</a></span>GetSupportedVideoModes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structvlk_1_1vlfw_1_1VideoMode.html">VideoMode</a>&gt;&amp; vlk::vlfw::Monitor::GetSupportedVideoModes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all supported output modes of the monitor. </p>
<dl class="section user"><dt>Thread Safety</dt><dd>This function must only be called from the main thread.<br  />
 Access to this class is not synchronized.<br  />
 This function will not block the calling thread.<br  />
 </dd></dl>

</div>
</div>
<a id="aa39a773bda3d1bc7efdb860875168666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39a773bda3d1bc7efdb860875168666">&#9670;&nbsp;</a></span>GetVideoMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvlk_1_1vlfw_1_1VideoMode.html">VideoMode</a> Monitor::GetVideoMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current output mode of the monitor. </p>
<dl class="section user"><dt>Thread Safety</dt><dd>This function must only be called from the main thread.<br  />
 Access to this class is not synchronized.<br  />
 This function will not block the calling thread.<br  />
 </dd></dl>

</div>
</div>
<a id="a6f26479874f049edffb4018cf1f5afa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f26479874f049edffb4018cf1f5afa3">&#9670;&nbsp;</a></span>GetWorkingArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Area&lt; Int &gt; Monitor::GetWorkingArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the available working area of the monitor in screen coordinates. </p>
<dl class="section user"><dt>From GLFW's Documentation</dt><dd>The work area is defined as the area of the monitor not occluded by the operating system task bar where present. If no task bar exists then the work area is the monitor resolution in screen coordinates.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function must only be called from the main thread.<br  />
 Access to this class is not synchronized.<br  />
 This function will not block the calling thread.<br  />
 </dd></dl>

</div>
</div>
<a id="a65f2a7e22ff17bb16166116d8a8700a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f2a7e22ff17bb16166116d8a8700a9">&#9670;&nbsp;</a></span>SetGamma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Monitor::SetGamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the gamma exponent of the monitor. </p>
<p>This function auto-generates a gamma ramp from the specified exponent value and applies it to the monitor. More granular gamma control can be achieved through <a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#aac9c04207b687a8e08c659c221054ddf" title="Sets the full gamma ramp of the monitor.">SetGammaRamp()</a></p>
<dl class="section user"><dt>Thread Safety</dt><dd>This function must only be called from the main thread.<br  />
 Access to this class is not synchronized.<br  />
 This function will not block the calling thread.<br  />
 </dd></dl>

</div>
</div>
<a id="aac9c04207b687a8e08c659c221054ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9c04207b687a8e08c659c221054ddf">&#9670;&nbsp;</a></span>SetGammaRamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Monitor::SetGammaRamp </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Color &gt; &amp;&#160;</td>
          <td class="paramname"><em>ramp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the full gamma ramp of the monitor. </p>
<p>For best results, this gamma ramp should have the same length as that initially returned by <a class="el" href="classvlk_1_1vlfw_1_1Monitor.html#a5d192bb15a85276bf12566979f2861c6" title="Gets the gamma ramp of the monitor.">GetGammaRamp()</a>.</p>
<dl class="section user"><dt>From GLFW's Documentation</dt><dd>The software controlled gamma ramp is applied in addition to the hardware gamma correction, which today is usually an approximation of sRGB gamma. This means that setting a perfectly linear ramp, or gamma 1.0, will produce the default (usually sRGB-like) behavior.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>This function must only be called from the main thread.<br  />
 Access to this class is not synchronized.<br  />
 This function will not block the calling thread.<br  />
 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/VLFW/<a class="el" href="Monitor_8hpp_source.html">Monitor.hpp</a></li>
<li>src/VLFW.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
